{"version":3,"sources":["../src/index.ts","../node_modules/numeric-quantity/src/constants.ts","../node_modules/numeric-quantity/src/parseRomanNumerals.ts","../node_modules/numeric-quantity/src/numericQuantity.ts","../src/constants.ts","../src/parseIngredient.ts"],"sourcesContent":["export * from './parseIngredient';\nexport * from './constants';\nexport * from './types';\n","import type {\n  NumericQuantityOptions,\n  RomanNumeralAscii,\n  RomanNumeralUnicode,\n  VulgarFraction,\n} from './types';\n\n// #region Arabic numerals\n/**\n * Map of Unicode fraction code points to their ASCII equivalents.\n */\nexport const vulgarFractionToAsciiMap = {\n  '¼': '1/4',\n  '½': '1/2',\n  '¾': '3/4',\n  '⅐': '1/7',\n  '⅑': '1/9',\n  '⅒': '1/10',\n  '⅓': '1/3',\n  '⅔': '2/3',\n  '⅕': '1/5',\n  '⅖': '2/5',\n  '⅗': '3/5',\n  '⅘': '4/5',\n  '⅙': '1/6',\n  '⅚': '5/6',\n  '⅛': '1/8',\n  '⅜': '3/8',\n  '⅝': '5/8',\n  '⅞': '7/8',\n  '⅟': '1/',\n} as const satisfies Record<VulgarFraction, string>;\n\n/**\n * Captures the individual elements of a numeric string.\n *\n * Capture groups:\n *\n * |  #  |    Description                                   |        Example(s)                                                   |\n * | --- | ------------------------------------------------ | ------------------------------------------------------------------- |\n * | `0` | entire string                                    | `\"2 1/3\"` from `\"2 1/3\"`                                            |\n * | `1` | \"negative\" dash                                  | `\"-\"` from `\"-2 1/3\"`                                               |\n * | `2` | whole number or numerator                        | `\"2\"` from `\"2 1/3\"`; `\"1\"` from `\"1/3\"`                            |\n * | `3` | entire fraction, decimal portion, or denominator | `\" 1/3\"` from `\"2 1/3\"`; `\".33\"` from `\"2.33\"`; `\"/3\"` from `\"1/3\"` |\n *\n * _Capture group 2 may include comma/underscore separators._\n *\n * @example\n *\n * ```ts\n * numericRegex.exec(\"1\")     // [ \"1\",     \"1\", null,   null ]\n * numericRegex.exec(\"1.23\")  // [ \"1.23\",  \"1\", \".23\",  null ]\n * numericRegex.exec(\"1 2/3\") // [ \"1 2/3\", \"1\", \" 2/3\", \" 2\" ]\n * numericRegex.exec(\"2/3\")   // [ \"2/3\",   \"2\", \"/3\",   null ]\n * numericRegex.exec(\"2 / 3\") // [ \"2 / 3\", \"2\", \"/ 3\",  null ]\n * ```\n */\nexport const numericRegex =\n  /^(?=-?\\s*\\.\\d|-?\\s*\\d)(-)?\\s*((?:\\d(?:[\\d,_]*\\d)?)*)(([eE][+-]?\\d(?:[\\d,_]*\\d)?)?|\\.\\d(?:[\\d,_]*\\d)?([eE][+-]?\\d(?:[\\d,_]*\\d)?)?|(\\s+\\d(?:[\\d,_]*\\d)?\\s*)?\\s*\\/\\s*\\d(?:[\\d,_]*\\d)?)?$/;\n/**\n * Same as {@link numericRegex}, but allows (and ignores) trailing invalid characters.\n */\nexport const numericRegexWithTrailingInvalid = new RegExp(\n  numericRegex.source.replace(/\\$$/, '(?:\\\\s*[^\\\\.\\\\d\\\\/].*)?')\n);\n\n/**\n * Captures any Unicode vulgar fractions.\n */\nexport const vulgarFractionsRegex = new RegExp(\n  `(${Object.keys(vulgarFractionToAsciiMap).join('|')})`\n);\n// #endregion\n\n// #region Roman numerals\ntype RomanNumeralSequenceFragment =\n  | `${RomanNumeralAscii}`\n  | `${RomanNumeralAscii}${RomanNumeralAscii}`\n  | `${RomanNumeralAscii}${RomanNumeralAscii}${RomanNumeralAscii}`\n  | `${RomanNumeralAscii}${RomanNumeralAscii}${RomanNumeralAscii}${RomanNumeralAscii}`;\n\n/**\n * Map of Roman numeral sequences to their decimal equivalents.\n */\nexport const romanNumeralValues = {\n  MMM: 3000,\n  MM: 2000,\n  M: 1000,\n  CM: 900,\n  DCCC: 800,\n  DCC: 700,\n  DC: 600,\n  D: 500,\n  CD: 400,\n  CCC: 300,\n  CC: 200,\n  C: 100,\n  XC: 90,\n  LXXX: 80,\n  LXX: 70,\n  LX: 60,\n  L: 50,\n  XL: 40,\n  XXX: 30,\n  XX: 20,\n  XII: 12, // only here for tests; not used in practice\n  XI: 11, // only here for tests; not used in practice\n  X: 10,\n  IX: 9,\n  VIII: 8,\n  VII: 7,\n  VI: 6,\n  V: 5,\n  IV: 4,\n  III: 3,\n  II: 2,\n  I: 1,\n} as const satisfies { [k in RomanNumeralSequenceFragment]?: number };\n\n/**\n * Map of Unicode Roman numeral code points to their ASCII equivalents.\n */\nexport const romanNumeralUnicodeToAsciiMap = {\n  // Roman Numeral One (U+2160)\n  Ⅰ: 'I',\n  // Roman Numeral Two (U+2161)\n  Ⅱ: 'II',\n  // Roman Numeral Three (U+2162)\n  Ⅲ: 'III',\n  // Roman Numeral Four (U+2163)\n  Ⅳ: 'IV',\n  // Roman Numeral Five (U+2164)\n  Ⅴ: 'V',\n  // Roman Numeral Six (U+2165)\n  Ⅵ: 'VI',\n  // Roman Numeral Seven (U+2166)\n  Ⅶ: 'VII',\n  // Roman Numeral Eight (U+2167)\n  Ⅷ: 'VIII',\n  // Roman Numeral Nine (U+2168)\n  Ⅸ: 'IX',\n  // Roman Numeral Ten (U+2169)\n  Ⅹ: 'X',\n  // Roman Numeral Eleven (U+216A)\n  Ⅺ: 'XI',\n  // Roman Numeral Twelve (U+216B)\n  Ⅻ: 'XII',\n  // Roman Numeral Fifty (U+216C)\n  Ⅼ: 'L',\n  // Roman Numeral One Hundred (U+216D)\n  Ⅽ: 'C',\n  // Roman Numeral Five Hundred (U+216E)\n  Ⅾ: 'D',\n  // Roman Numeral One Thousand (U+216F)\n  Ⅿ: 'M',\n  // Small Roman Numeral One (U+2170)\n  ⅰ: 'I',\n  // Small Roman Numeral Two (U+2171)\n  ⅱ: 'II',\n  // Small Roman Numeral Three (U+2172)\n  ⅲ: 'III',\n  // Small Roman Numeral Four (U+2173)\n  ⅳ: 'IV',\n  // Small Roman Numeral Five (U+2174)\n  ⅴ: 'V',\n  // Small Roman Numeral Six (U+2175)\n  ⅵ: 'VI',\n  // Small Roman Numeral Seven (U+2176)\n  ⅶ: 'VII',\n  // Small Roman Numeral Eight (U+2177)\n  ⅷ: 'VIII',\n  // Small Roman Numeral Nine (U+2178)\n  ⅸ: 'IX',\n  // Small Roman Numeral Ten (U+2179)\n  ⅹ: 'X',\n  // Small Roman Numeral Eleven (U+217A)\n  ⅺ: 'XI',\n  // Small Roman Numeral Twelve (U+217B)\n  ⅻ: 'XII',\n  // Small Roman Numeral Fifty (U+217C)\n  ⅼ: 'L',\n  // Small Roman Numeral One Hundred (U+217D)\n  ⅽ: 'C',\n  // Small Roman Numeral Five Hundred (U+217E)\n  ⅾ: 'D',\n  // Small Roman Numeral One Thousand (U+217F)\n  ⅿ: 'M',\n} as const satisfies Record<\n  RomanNumeralUnicode,\n  keyof typeof romanNumeralValues\n>;\n\n/**\n * Captures all Unicode Roman numeral code points.\n */\nexport const romanNumeralUnicodeRegex = new RegExp(\n  `(${Object.keys(romanNumeralUnicodeToAsciiMap).join('|')})`,\n  'gi'\n);\n\n/**\n * Captures a valid Roman numeral sequence.\n *\n * Capture groups:\n *\n * |  #  |  Description    |         Example          |\n * | --- | --------------- | ------------------------ |\n * | `0` |  Entire string  |  \"MCCXIV\" from \"MCCXIV\"  |\n * | `1` |  Thousands      |  \"M\" from \"MCCXIV\"       |\n * | `2` |  Hundreds       |  \"CC\" from \"MCCXIV\"      |\n * | `3` |  Tens           |  \"X\" from \"MCCXIV\"       |\n * | `4` |  Ones           |  \"IV\" from \"MCCXIV\"      |\n *\n * @example\n *\n * ```ts\n * romanNumeralRegex.exec(\"M\")      // [      \"M\", \"M\",   \"\",  \"\",   \"\" ]\n * romanNumeralRegex.exec(\"XII\")    // [    \"XII\",  \"\",   \"\", \"X\", \"II\" ]\n * romanNumeralRegex.exec(\"MCCXIV\") // [ \"MCCXIV\", \"M\", \"CC\", \"X\", \"IV\" ]\n * ```\n */\nexport const romanNumeralRegex =\n  /^(?=[MDCLXVI])(M{0,3})(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$/i;\n// #endregion\n\n/**\n * Default options for {@link numericQuantity}.\n */\nexport const defaultOptions = {\n  round: 3,\n  allowTrailingInvalid: false,\n  romanNumerals: false,\n} satisfies Required<NumericQuantityOptions>;\n","import {\n  romanNumeralRegex,\n  romanNumeralUnicodeRegex,\n  romanNumeralUnicodeToAsciiMap,\n  romanNumeralValues,\n} from './constants';\n\n// Just a shorthand type alias\ntype RNV = keyof typeof romanNumeralValues;\n\n/**\n * Converts a string of Roman numerals to a number, like `parseInt`\n * for Roman numerals. Uses modern, strict rules (only 1 to 3999).\n *\n * The string can include ASCII representations of Roman numerals\n * or Unicode Roman numeral code points (`U+2160` through `U+217F`).\n */\nexport const parseRomanNumerals = (romanNumerals: string) => {\n  const normalized = `${romanNumerals}`\n    // Convert Unicode Roman numerals to ASCII\n    .replace(\n      romanNumeralUnicodeRegex,\n      (_m, rn: keyof typeof romanNumeralUnicodeToAsciiMap) =>\n        romanNumeralUnicodeToAsciiMap[rn]\n    )\n    // Normalize to uppercase (more common for Roman numerals)\n    .toUpperCase();\n\n  const regexResult = romanNumeralRegex.exec(normalized);\n\n  if (!regexResult) {\n    return NaN;\n  }\n\n  const [, thousands, hundreds, tens, ones] = regexResult;\n\n  return (\n    (romanNumeralValues[thousands as RNV] ?? 0) +\n    (romanNumeralValues[hundreds as RNV] ?? 0) +\n    (romanNumeralValues[tens as RNV] ?? 0) +\n    (romanNumeralValues[ones as RNV] ?? 0)\n  );\n};\n","import {\n  defaultOptions,\n  numericRegex,\n  numericRegexWithTrailingInvalid,\n  vulgarFractionToAsciiMap,\n  vulgarFractionsRegex,\n} from './constants';\nimport { parseRomanNumerals } from './parseRomanNumerals';\nimport type { NumericQuantityOptions } from './types';\n\nconst spaceThenSlashRegex = /^\\s*\\//;\n\n/**\n * Converts a string to a number, like an enhanced version of `parseFloat`.\n *\n * The string can include mixed numbers, vulgar fractions, or Roman numerals.\n */\nexport const numericQuantity = (\n  quantity: string | number,\n  options: NumericQuantityOptions = defaultOptions\n) => {\n  if (typeof quantity === 'number' || typeof quantity === 'bigint') {\n    return quantity;\n  }\n\n  let finalResult = NaN;\n\n  // Coerce to string in case qty is a number\n  const quantityAsString = `${quantity}`\n    // Convert vulgar fractions to ASCII, with a leading space\n    // to keep the whole number and the fraction separate\n    .replace(\n      vulgarFractionsRegex,\n      (_m, vf: keyof typeof vulgarFractionToAsciiMap) =>\n        ` ${vulgarFractionToAsciiMap[vf]}`\n    )\n    // Convert fraction slash to standard slash\n    .replace('⁄', '/')\n    .trim();\n\n  // Bail out if the string was only white space\n  if (quantityAsString.length === 0) {\n    return NaN;\n  }\n\n  const opts: Required<NumericQuantityOptions> = {\n    ...defaultOptions,\n    ...options,\n  };\n\n  const regexResult = (\n    opts.allowTrailingInvalid ? numericRegexWithTrailingInvalid : numericRegex\n  ).exec(quantityAsString);\n\n  // If the Arabic numeral regex fails, try Roman numerals\n  if (!regexResult) {\n    return opts.romanNumerals ? parseRomanNumerals(quantityAsString) : NaN;\n  }\n\n  const [, dash, ng1temp, ng2temp] = regexResult;\n  const numberGroup1 = ng1temp.replace(/[,_]/g, '');\n  const numberGroup2 = ng2temp?.replace(/[,_]/g, '');\n\n  // Numerify capture group 1\n  if (!numberGroup1 && numberGroup2 && numberGroup2.startsWith('.')) {\n    finalResult = 0;\n  } else {\n    finalResult = parseInt(numberGroup1);\n  }\n\n  // If capture group 2 is null, then we're dealing with an integer\n  // and there is nothing left to process\n  if (!numberGroup2) {\n    return dash ? finalResult * -1 : finalResult;\n  }\n\n  const roundingFactor =\n    opts.round === false\n      ? NaN\n      : parseFloat(`1e${Math.floor(Math.max(0, opts.round))}`);\n\n  if (\n    numberGroup2.startsWith('.') ||\n    numberGroup2.startsWith('e') ||\n    numberGroup2.startsWith('E')\n  ) {\n    // If first char of `numberGroup2` is \".\" or \"e\"/\"E\", it's a decimal\n    const decimalValue = parseFloat(`${finalResult}${numberGroup2}`);\n    finalResult = isNaN(roundingFactor)\n      ? decimalValue\n      : Math.round(decimalValue * roundingFactor) / roundingFactor;\n  } else if (spaceThenSlashRegex.test(numberGroup2)) {\n    // If the first non-space char is \"/\" it's a pure fraction (e.g. \"1/2\")\n    const numerator = parseInt(numberGroup1);\n    const denominator = parseInt(numberGroup2.replace('/', ''));\n    finalResult = isNaN(roundingFactor)\n      ? numerator / denominator\n      : Math.round((numerator * roundingFactor) / denominator) / roundingFactor;\n  } else {\n    // Otherwise it's a mixed fraction (e.g. \"1 2/3\")\n    const fractionArray = numberGroup2.split('/');\n    const [numerator, denominator] = fractionArray.map(v => parseInt(v));\n    finalResult += isNaN(roundingFactor)\n      ? numerator / denominator\n      : Math.round((numerator * roundingFactor) / denominator) / roundingFactor;\n  }\n\n  return dash ? finalResult * -1 : finalResult;\n};\n","import { numericRegex } from 'numeric-quantity';\nimport { ParseIngredientOptions, UnitOfMeasureDefinitions } from './types';\n\n/**\n * Default options for {@link parseIngredient}.\n */\nexport const defaultOptions: Required<ParseIngredientOptions> = {\n  additionalUOMs: {},\n  allowLeadingOf: false,\n  normalizeUOM: false,\n  ignoreUOMs: [],\n} as const;\n\n/**\n * List of \"for\" equivalents (for upcoming i18n support).\n */\nexport const fors = ['For'] as const;\n/**\n * Regex to capture \"for\" equivalents (for upcoming i18n support).\n */\nexport const forsRegEx: RegExp = new RegExp(`^(?:${fors.join('|')})\\\\s`, 'i');\n\n/**\n * List of range separators (for upcoming i18n support).\n */\nexport const rangeSeparatorWords = ['or', 'to'] as const;\nconst rangeSeparatorRegExSource = `(-|–|—|(?:${rangeSeparatorWords.join('|')})\\\\s)`;\n/**\n * Regex to capture range separators (for upcoming i18n support).\n */\nexport const rangeSeparatorRegEx: RegExp = new RegExp(`^${rangeSeparatorRegExSource}`, 'i');\n\n/**\n * Regex to capture the first word of a description, to see if it's a unit of measure.\n */\nexport const firstWordRegEx: RegExp = /^(fl(?:uid)?(?:\\s+|-)(?:oz|ounces?)|\\w+[-.]?)(.+)?/;\n\nconst numericRegexAnywhere = numericRegex.source.replace(/^\\^/, '').replace(/\\$$/, '');\n\n/**\n * Regex to capture trailing quantity and unit of measure.\n */\nexport const trailingQuantityRegEx: RegExp = new RegExp(\n  `(,|:|-|–|—|x|⨯)?\\\\s*((${numericRegexAnywhere})\\\\s*(${rangeSeparatorRegExSource}))?\\\\s*(${numericRegexAnywhere})\\\\s*(fl(?:uid)?(?:\\\\s+|-)(?:oz|ounces?)|\\\\w+)?$`,\n  'i'\n);\n\n/**\n * List of \"of\" equivalents (for upcoming i18n support).\n */\nexport const ofs = ['of'] as const;\n/**\n * Regex to capture \"of\" equivalents at the beginning of a string (for upcoming i18n support).\n */\nexport const ofRegEx: RegExp = new RegExp(`^(?:${ofs.join('|')})\\\\s+`, 'i');\n\n/**\n * List of \"from\" equivalents (for upcoming i18n support).\n */\nexport const froms = ['from', 'of'] as const;\n/**\n * Regex to capture \"from\" equivalents at the end of a string (for upcoming i18n support).\n */\nexport const fromRegEx: RegExp = new RegExp(`\\\\s+(?:${froms.join('|')})$`, 'i');\n\n/**\n * Default unit of measure specifications.\n */\nexport const unitsOfMeasure: UnitOfMeasureDefinitions = {\n  bag: {\n    short: 'bag',\n    plural: 'bags',\n    alternates: [] satisfies string[],\n  },\n  box: {\n    short: 'box',\n    plural: 'boxes',\n    alternates: [] satisfies string[],\n  },\n  bunch: {\n    short: 'bunch',\n    plural: 'bunches',\n    alternates: [] satisfies string[],\n  },\n  can: {\n    short: 'can',\n    plural: 'cans',\n    alternates: [] satisfies string[],\n  },\n  carton: {\n    short: 'carton',\n    plural: 'cartons',\n    alternates: [] satisfies string[],\n  },\n  centimeter: {\n    short: 'cm',\n    plural: 'centimeters',\n    alternates: ['cm.'] satisfies string[],\n  },\n  clove: {\n    short: 'clove',\n    plural: 'cloves',\n    alternates: [] satisfies string[],\n  },\n  container: {\n    short: 'container',\n    plural: 'containers',\n    alternates: [] satisfies string[],\n  },\n  cup: {\n    short: 'c',\n    plural: 'cups',\n    alternates: ['c.', 'C'] satisfies string[],\n  },\n  dash: {\n    short: 'dash',\n    plural: 'dashes',\n    alternates: [] satisfies string[],\n  },\n  drop: {\n    short: 'drop',\n    plural: 'drops',\n    alternates: [] satisfies string[],\n  },\n  ear: {\n    short: 'ear',\n    plural: 'ears',\n    alternates: [] satisfies string[],\n  },\n  'fluid ounce': {\n    short: 'fl oz',\n    plural: 'fluid ounces',\n    alternates: [\n      'fluidounce',\n      'floz',\n      'fl-oz',\n      'fluid-ounce',\n      'fluid-ounces',\n      'fluidounces',\n      'fl ounce',\n      'fl ounces',\n      'fl-ounce',\n      'fl-ounces',\n      'fluid oz',\n      'fluid-oz',\n    ] satisfies string[],\n  },\n  foot: {\n    short: 'ft',\n    plural: 'feet',\n    alternates: ['ft.'] satisfies string[],\n  },\n  gallon: {\n    short: 'gal',\n    plural: 'gallons',\n    alternates: ['gal.'] satisfies string[],\n  },\n  gram: {\n    short: 'g',\n    plural: 'grams',\n    alternates: ['g.'] satisfies string[],\n  },\n  head: {\n    short: 'head',\n    plural: 'heads',\n    alternates: [] satisfies string[],\n  },\n  inch: {\n    short: 'in',\n    plural: 'inches',\n    alternates: ['in.'] satisfies string[],\n  },\n  kilogram: {\n    short: 'kg',\n    plural: 'kilograms',\n    alternates: ['kg.'] satisfies string[],\n  },\n  large: {\n    short: 'lg',\n    plural: 'large',\n    alternates: ['lg', 'lg.'] satisfies string[],\n  },\n  liter: {\n    short: 'l',\n    plural: 'liters',\n    alternates: ['l.'] satisfies string[],\n  },\n  medium: {\n    short: 'md',\n    plural: 'medium',\n    alternates: ['med', 'med.', 'md.'] satisfies string[],\n  },\n  meter: {\n    short: 'm',\n    plural: 'meters',\n    alternates: ['m.'] satisfies string[],\n  },\n  milligram: {\n    short: 'mg',\n    plural: 'milligrams',\n    alternates: ['mg.'] satisfies string[],\n  },\n  milliliter: {\n    short: 'ml',\n    plural: 'milliliters',\n    alternates: ['mL', 'ml.', 'mL.'] satisfies string[],\n  },\n  millimeter: {\n    short: 'mm',\n    plural: 'millimeters',\n    alternates: ['mm.'] satisfies string[],\n  },\n  ounce: {\n    short: 'oz',\n    plural: 'ounces',\n    alternates: ['oz.'] satisfies string[],\n  },\n  pack: {\n    short: 'pack',\n    plural: 'packs',\n    alternates: [] satisfies string[],\n  },\n  package: {\n    short: 'pkg',\n    plural: 'packages',\n    alternates: ['pkg.', 'pkgs', 'pkgs.'] satisfies string[],\n  },\n  piece: {\n    short: 'piece',\n    plural: 'pieces',\n    alternates: ['pc', 'pc.', 'pcs', 'pcs.'] satisfies string[],\n  },\n  pinch: {\n    short: 'pinch',\n    plural: 'pinches',\n    alternates: [] satisfies string[],\n  },\n  pint: {\n    short: 'pt',\n    plural: 'pints',\n    alternates: ['pt.'] satisfies string[],\n  },\n  pound: {\n    short: 'lb',\n    plural: 'pounds',\n    alternates: ['lb.', 'lbs', 'lbs.'] satisfies string[],\n  },\n  quart: {\n    short: 'qt',\n    plural: 'quarts',\n    alternates: ['qt.', 'qts', 'qts.'] satisfies string[],\n  },\n  small: {\n    short: 'sm',\n    plural: 'small',\n    alternates: ['sm.'] satisfies string[],\n  },\n  sprig: {\n    short: 'sprig',\n    plural: 'sprigs',\n    alternates: [] satisfies string[],\n  },\n  stick: {\n    short: 'stick',\n    plural: 'sticks',\n    alternates: [] satisfies string[],\n  },\n  tablespoon: {\n    short: 'tbsp',\n    plural: 'tablespoons',\n    alternates: ['tbsp.', 'T', 'Tbsp.', 'Tbsp'] satisfies string[],\n  },\n  teaspoon: {\n    short: 'tsp',\n    plural: 'teaspoons',\n    alternates: ['tsp.', 't'] satisfies string[],\n  },\n  yard: {\n    short: 'yd',\n    plural: 'yards',\n    alternates: ['yd.', 'yds.'] satisfies string[],\n  },\n} as const;\n","import { numericQuantity } from 'numeric-quantity';\nimport {\n  defaultOptions,\n  firstWordRegEx,\n  forsRegEx,\n  fromRegEx,\n  ofRegEx,\n  rangeSeparatorRegEx,\n  trailingQuantityRegEx,\n  unitsOfMeasure,\n} from './constants';\nimport type { Ingredient, ParseIngredientOptions, UnitOfMeasure } from './types';\n\nconst newLineRegExp = /\\r?\\n/;\n\nconst addIdToUomDefinition = ([uom, def]: [string, UnitOfMeasure]) => ({ id: uom, ...def });\n\n/**\n * Parses a string into an array of recipe ingredient objects\n */\nexport const parseIngredient = (\n  /**\n   * The ingredient list, as plain text.\n   */\n  ingredientText: string,\n  /**\n   * Configuration options. Defaults to {@link defaultOptions}.\n   */\n  options: ParseIngredientOptions = defaultOptions\n): Ingredient[] => {\n  const opts = { ...defaultOptions, ...options };\n  const mergedUOMs = { ...unitsOfMeasure, ...opts.additionalUOMs };\n  const uomArray = Object.entries(mergedUOMs).map(addIdToUomDefinition);\n  const uomArrayLength = uomArray.length;\n\n  const ingredientArray = ingredientText\n    .split(newLineRegExp)\n    .map(line => line.trim())\n    .filter(Boolean);\n\n  return ingredientArray.map(line => {\n    const oIng: Ingredient = {\n      quantity: null,\n      quantity2: null,\n      unitOfMeasureID: null,\n      unitOfMeasure: null,\n      description: '',\n      isGroupHeader: false,\n    };\n\n    // Check if the first character is numeric.\n    if (isNaN(numericQuantity(line[0]))) {\n      // The first character is not numeric. First check for trailing quantity/uom.\n      const trailingQtyResult = trailingQuantityRegEx.exec(line);\n\n      if (trailingQtyResult && opts.ignoreUOMs.includes(trailingQtyResult.at(-1) ?? '')) {\n        // Trailing quantity detected, but bailing out since the UOM should be ignored.\n        oIng.description = line;\n      } else if (trailingQtyResult) {\n        // Trailing quantity detected with missing or non-ignored UOM.\n        // Remove the quantity and unit of measure from the description.\n        oIng.description = line.replace(trailingQuantityRegEx, '').trim();\n\n        // Trailing quantity/range.\n        const firstQty = trailingQtyResult[3];\n        const secondQty = trailingQtyResult[12];\n        if (!firstQty) {\n          oIng.quantity = numericQuantity(secondQty);\n        } else {\n          oIng.quantity = numericQuantity(firstQty);\n          oIng.quantity2 = numericQuantity(secondQty);\n        }\n\n        // Trailing unit of measure.\n        const uomRaw = trailingQtyResult.at(-1);\n        if (uomRaw) {\n          let uom = '';\n          let uomID = '';\n          let i = -1;\n\n          while (++i < uomArrayLength && !uom) {\n            const { alternates, id, short, plural } = uomArray[i];\n            const versions = [...alternates, id, short, plural];\n            if (versions.includes(uomRaw)) {\n              uom = uomRaw;\n              uomID = id;\n            }\n          }\n\n          if (uom) {\n            oIng.unitOfMeasureID = uomID;\n            oIng.unitOfMeasure = opts.normalizeUOM ? uomID : uom;\n          } else if (oIng.description.match(fromRegEx)) {\n            oIng.description += ` ${uomRaw}`;\n          }\n        }\n      } else {\n        // The first character is not numeric, and no trailing quantity was detected,\n        // so the entire line is the description.\n        oIng.description = line;\n\n        // If the line ends with \":\" or starts with \"For \", then it is assumed to be a group header.\n        if (oIng.description.endsWith(':') || forsRegEx.test(oIng.description)) {\n          oIng.isGroupHeader = true;\n        }\n      }\n    } else {\n      // The first character is numeric. See how many of the first seven\n      // constitute a single value. This will be `quantity`.\n      let lenNum = 6;\n      let nqResult = NaN;\n\n      while (lenNum > 0 && isNaN(nqResult)) {\n        nqResult = numericQuantity(line.substring(0, lenNum).trim());\n\n        if (nqResult > -1) {\n          oIng.quantity = nqResult;\n          oIng.description = line.substring(lenNum).trim();\n        }\n\n        lenNum--;\n      }\n    }\n\n    // Now check the description for a `quantity2` at the beginning.\n    // First we look for a dash, emdash, endash, \"to \", or \"or \" to\n    // indicate a range, then process the next seven characters just\n    // like we did for `quantity`.\n    const q2reMatch = rangeSeparatorRegEx.exec(oIng.description);\n    if (q2reMatch) {\n      const q2reMatchLen = q2reMatch[1].length;\n      const nqResultFirstChar = numericQuantity(oIng.description.substring(q2reMatchLen).trim()[0]);\n\n      if (!isNaN(nqResultFirstChar)) {\n        let lenNum = 7;\n        let nqResult = NaN;\n\n        while (--lenNum > 0 && isNaN(nqResult)) {\n          nqResult = numericQuantity(oIng.description.substring(q2reMatchLen, lenNum));\n\n          if (!isNaN(nqResult)) {\n            oIng.quantity2 = nqResult;\n            oIng.description = oIng.description.substring(lenNum).trim();\n          }\n        }\n      }\n    }\n\n    // Check for a known unit of measure\n    const firstWordREMatches = firstWordRegEx.exec(oIng.description);\n\n    if (firstWordREMatches) {\n      const firstWord = firstWordREMatches[1].replace(/\\s+/g, ' ');\n      const remainingDesc = (firstWordREMatches[2] ?? '').trim();\n      if (remainingDesc) {\n        let uom = '';\n        let uomID = '';\n        let i = -1;\n\n        while (++i < uomArrayLength && !uom) {\n          const { alternates, id, short, plural } = uomArray[i];\n          const versions = [...alternates, id, short, plural].filter(\n            unit => !opts.ignoreUOMs.includes(unit)\n          );\n          if (versions.includes(firstWord)) {\n            uom = firstWord;\n            uomID = id;\n          }\n        }\n\n        if (uom) {\n          oIng.unitOfMeasureID = uomID;\n          oIng.unitOfMeasure = opts.normalizeUOM ? uomID : uom;\n          oIng.description = remainingDesc;\n        }\n      }\n    }\n\n    if (!opts.allowLeadingOf && oIng.description.match(ofRegEx)) {\n      oIng.description = oIng.description.replace(ofRegEx, '');\n    }\n\n    return oIng;\n  });\n};\n"],"mappings":"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","names":["src_exports","__export","defaultOptions","firstWordRegEx","fors","forsRegEx","fromRegEx","froms","ofRegEx","ofs","parseIngredient","rangeSeparatorRegEx","rangeSeparatorWords","trailingQuantityRegEx","unitsOfMeasure","vulgarFractionToAsciiMap","numericRegex","numericRegexWithTrailingInvalid","vulgarFractionsRegex","romanNumeralValues","romanNumeralUnicodeToAsciiMap","romanNumeralUnicodeRegex","romanNumeralRegex","defaultOptions","parseRomanNumerals","romanNumerals","normalized","_m","rn","regexResult","thousands","hundreds","tens","ones","spaceThenSlashRegex","numericQuantity","quantity","options","finalResult","quantityAsString","vf","opts","dash","ng1temp","ng2temp","numberGroup1","numberGroup2","roundingFactor","decimalValue","numerator","denominator","fractionArray","v","defaultOptions","fors","forsRegEx","rangeSeparatorWords","rangeSeparatorRegExSource","rangeSeparatorRegEx","firstWordRegEx","numericRegexAnywhere","numericRegex","trailingQuantityRegEx","ofs","ofRegEx","froms","fromRegEx","unitsOfMeasure","newLineRegExp","addIdToUomDefinition","uom","def","parseIngredient","ingredientText","options","defaultOptions","opts","mergedUOMs","unitsOfMeasure","uomArray","uomArrayLength","line","oIng","numericQuantity","trailingQtyResult","trailingQuantityRegEx","firstQty","secondQty","uomRaw","uomID","i","alternates","id","short","plural","fromRegEx","forsRegEx","lenNum","nqResult","q2reMatch","rangeSeparatorRegEx","q2reMatchLen","nqResultFirstChar","firstWordREMatches","firstWordRegEx","firstWord","remainingDesc","unit","ofRegEx"]}